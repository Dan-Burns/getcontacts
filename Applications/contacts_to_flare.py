#!/usr/bin/env python3

"""
Takes a list of atomic contacts as input and generates a json representing a
temporal flare which can be visualized using flareplots.

A subset of interaction types can be selected using the --itype argument which
is formatted as a comma-separated list of abbreviations corresponding to
    sb             salt bridges
    pc             pi-cation
    ps             pi-stacking
    ts             t-stacking
    vdw            van der Waals
    hb             hydrogen bonds
    lhb            ligand hydrogen bonds
    hbbb           backbone-backbone hydrogen bonds
    hbsb           backbone-sidechain hydrogen bonds
    hbss           sidechain-sidechain hydrogen bonds
    wb             water bridges
    wb2            extended water bridges
    hls            ligand-sidechain residue hydrogen bonds
    hlb            ligand-backbone residue hydrogen bonds
    lwb            ligand water bridges
    lwb2           extended ligand water bridges

By default, the labels on the plot will reflect the residue identifier.
Optionally, a "flare-label" file can be supplied which indicates how residue
identifiers should be translated to flare-plot labels. The flare-label file is
a tab-separated text-file where each line has one field that indicates a colon-
separated residue identifier and one field that indicates the corresponding
flareplot label. Dots in the flareplot labels can be used to group and organize
labels. A valid flare-label file would look like this:
    A:ARG:4  Root.Helix1.1x30
    A:LYS:5  Root.Helix1.1x31
    ...
    A:PRO:45 Root.Helix2.2x36
    A:MET:46 Root.Helix2.2x37
    ...
The flare-label file can also act as a filter, as interactions between residues
that are not included in the file will be excluded from the plot. For
convenience it's not necessary to include the second column if the label file
is just used as a filter. A third column can be supplied indicating a color in
CSS-format (e.g. '#FF0000' or 'red').
"""


def main():
    """
    Main function called once at the end of this module. Configures and parses command line arguments, parses input
    files and generates output files.
    """
    # Parse command line arguments
    import argparse as ap
    parser = ap.ArgumentParser(description=__doc__, formatter_class=ap.RawTextHelpFormatter)
    optional = parser._action_groups.pop()
    required = parser.add_argument_group('required arguments')
    parser._action_groups.append(optional)  # added this line

    required.add_argument('--input',
                          required=True,
                          type=ap.FileType('r'),
                          help='A multi-frame contact-file generated by dynamic_contact.py')
    required.add_argument('--output',
                          required=False,
                          type=ap.FileType('w'),
                          help='The json file to write flare to')

    optional.add_argument('--itype',
                          required=False,
                          default="all",
                          type=str,
                          help='Interaction types to include (comma separated list) [default: all]')
    optional.add_argument('--flarelabels',
                          required=False,
                          default=None,
                          type=ap.FileType('r'),
                          help='Flare-label file')

    args = parser.parse_args()

    if args.output:
        print("Parsing %s contacts from %s" % (args.itype, args.input.name))

    # Read contacts and generate graph
    itypes = parse_itypes(args.itype)
    contacts = parse_contacts(args.input, itypes)
    labels = parse_residuelabels(args.flarelabels)
    graph = create_flare(contacts, labels)

    # Convert string to pretty printed JSON
    import json
    pretty_json = json.dumps(graph, indent=2)

    # "frames" entries can contain a lot of digits so put those on a single line
    import re
    pretty_json = re.sub(r"(?<=\d,)\n *|(?<=\[)\n *(?=\d)|(?<=\d)\n *(?=\])", "", pretty_json, flags=re.MULTILINE)

    # Write to output file
    if args.output:
        args.output.write(pretty_json)
        args.output.close()
        print("Done - wrote flare-json to %s" % args.output.name)
    else:
        print(pretty_json)


def parse_itypes(itype_argument):
    """Parses the itype argument and returns a set of strings with all the selected interaction types """
    if "all" in itype_argument:
        return ["sb", "pc", "ps", "ts", "vdw", "hb", "lhb", "hbbb", "hbsb",
                "hbss", "wb", "wb2", "hls", "hlb", "lwb", "lwb2"]
    return set(itype_argument.split(","))


if __name__ == "__main__":
    main()


__license__ = "Apache License 2.0"
__maintainer__ = "Rasmus Fonseca"
__email__ = "fonseca.rasmus@gmail.com"
